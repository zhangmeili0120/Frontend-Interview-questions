

#### 20. 谈一谈你对vue响应式原理的理解？

1. 如何追踪变化

   - 一个普通的js对象作为data选项传入Vue，Vue会使用Object.defineProperty把属性全部转为getter/setter。这使得每个属性在被访问和修改时，vue可以监测到。
   - 每个组件实例都对应一个watcher实例，在组件渲染时把"接触"过的属性记录为依赖。之后当依赖项的setter触发时，会通知watcher,watcher会通知它关联的组件重新渲染。

2. 检测变化的注意事项

   - Vue **无法检测到对象属性的添加或删除**

     - 由于初始化了data中的getter/setter，所以属性必须在data上才是响应式的。

     - 嵌套对象修改属性

       this.$set(obj, key, value)

       或

       Vue.set(obj, key, value)

     - 嵌套对象增加或者删除属性

       this.sthObj = Object.assign({}, this.sthObj, {newKey: 123})

   - vue无法检测数组修改某一项或者修改长度

     - 数组修改某一项

       this.$set(arr, index, newValue)

       或

       vm.arr.splice(index, 1, newValue)

     - 修改数组长度

       vm.items.splice(startIndex)

3. 声明响应式属性

   - Vue 不允许动态添加根级响应式属性，必须在初始化实例前声明所有的根级别响应式属性。

4. 异步更新队列

   - Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。
   - 如果你想基于更新后的 DOM 状态来做点什么，为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。